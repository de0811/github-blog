---
aliases: 
tags:
  - Spring
  - Spring/Exception
  - index
  - Spring/공통처리
특징: 
---
# 예외
![[config/AttachedFile/Pasted image 20240526223106.png|600]]
> 예외 계층

- `Throwable` : 원칙적으로 `Throwable` 예외를 잡으면 안됨 (unChecked)
- `Error` : 메모리 부족이나 심각한 시스템 오류와 같이 애플리케이션에서 복구 불가능한 시스템 예외 (unChecked)
  애플리케이션 개발자는 이 예외를 잡으려고 해서는 안됨
- `Exception`  : `RuntimeException` 을 제외한 모두 컴파일 에러(Checked)
- `RuntimeException` : 런타임 예외(unChecked)

## 처리 유형
- Checked 예외 : 각 함수에서  처리 또는 던지기를 해야만 동작 가능
- unChecked 예외 : 잡거나 던지지 않아도 동작 가능(자동으로 밖으로 던짐)
기본적으로 unChecked 를 사용
비즈니스 로직상 의도적으로 던지는 예외의 경우만 checked 예외 사용

예전에는 Checked 형태의 예외를 기본으로 사용하는 것이 사용에 이점이 많을 것이라고 생각했지만 사용해본 결과 `Exception` 종류들에 너무 많은 종속성이 생기기 때문에 `unChecked` 방식인 `RuntimeException` 을 중점으로 사용하도록 추세가 변경

`{java icon title:"@Slf4j 에러 출력 방법"}log.info("예외 처리, message: {}", e.getMessage(), e);`
`{java icon title:"System.out 에러 출력 방법"}System.out.println(e.printStackTrace());`

```java
class RuntimeSQLException extends RuntimeException {  
  public RuntimeSQLException(Throwable cause) {  
    super(cause);  
  }  
}
```

# 예외에 따른 상황 복구 방법
`{java}SQLException` 에러의 경우 내부에 `getErrorCode()` 함수를 통해서 DB Error code 번호를 반환
반환된 번호를 보고 `SQLErrorCodeSQLExceptionTranslator` 통해 [[2.Ref(데이터 및 정보 저장)/Spring/Exception/DataAccessException|DataAccessException]] 생성
Spring 에서 지원하는 Exception 이라서 따라가는 것이 편함
![[config/AttachedFile/Pasted image 20240527155258.png|600]]

# 진행 방향
`WAS <- 필터 <- 서블릿 <- 인터셉터 <- 컨트롤러(예외발생)`
`WAS(에러페이지 요청) -> 필터 -> 서블릿 -> 인터셉터 -> 컨트롤러(/error-page/500) -> View`

Exception 발생시 500Error 기본 발생


# 설정
```properties
#오류페이지 경로, BasicErrorController 가 사용하는 경로 지정
server.error.path=/error
# whitelabel 이란 기본적으로 스프링부트에서 제공하는 에러페이지를 말한다.  
# whitelabel error page를 사용할지 선택  
server.error.whitelabel.enabled=false  
# error page에 exception을 포함할지 선택  
server.error.include-exception=true  
# error page에 message를 포함할지 선택  
server.error.include-message=always  
# error page에 stacktrace를 포함할지 선택  
server.error.include-stacktrace=always  
# error page에 binding error를 포함할지 선택  
server.error.include-binding-errors=always
```


```java
log.info("ERROR_EXCEPTION: {}", request.getAttribute(RequestDispatcher.ERROR_EXCEPTION));  
log.info("ERROR_EXCEPTION_TYPE: {}", request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE));  
log.info("ERROR_MESSAGE: {}", request.getAttribute(RequestDispatcher.ERROR_MESSAGE));  
log.info("ERROR_REQUEST_URI: {}", request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI));  
log.info("ERROR_SERVLET_NAME: {}", request.getAttribute(RequestDispatcher.ERROR_SERVLET_NAME));  
log.info("ERROR_STATUS_CODE: {}", request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE));  
log.info("dispatchType: {}", request.getDispatcherType());
```
> 설정에 따라 해당 정보가 보일지 말지 설정
# 에러 페이지 요청시 WAS에서 전달하는 데이터
`RequestDispatcher` 에서는 각종 에러를 미리 정의
```java
String ERROR_EXCEPTION = "jakarta.servlet.error.exception";  
String ERROR_EXCEPTION_TYPE = "jakarta.servlet.error.exception_type";  
String ERROR_MESSAGE = "jakarta.servlet.error.message";  
String ERROR_REQUEST_URI = "jakarta.servlet.error.request_uri";  
String ERROR_SERVLET_NAME = "jakarta.servlet.error.servlet_name";  
String ERROR_STATUS_CODE = "jakarta.servlet.error.status_code";
```

해당 데이터를 보기 위한 방법
```java
public void printErrorInfo(HttpServletRequest request) {  
  log.info("ERROR_EXCEPTION: {}", request.getAttribute(RequestDispatcher.ERROR_EXCEPTION));  
  log.info("ERROR_EXCEPTION_TYPE: {}", request.getAttribute(RequestDispatcher.ERROR_EXCEPTION_TYPE));  
  log.info("ERROR_MESSAGE: {}", request.getAttribute(RequestDispatcher.ERROR_MESSAGE));  
  log.info("ERROR_REQUEST_URI: {}", request.getAttribute(RequestDispatcher.ERROR_REQUEST_URI));  
  log.info("ERROR_SERVLET_NAME: {}", request.getAttribute(RequestDispatcher.ERROR_SERVLET_NAME));  
  log.info("ERROR_STATUS_CODE: {}", request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE));  
  log.info("dispatchType: {}", request.getDispatcherType());  
}
```

# 기타
아무 처리 없는 `Exception` 에러는 무조건 500 에러 반환
에러 직접 지정하는 방법 : `response.sendError(numError, strError)`

# Exception 처리 방법

## 에러 페이지 등록 방법
- web.xml 
- WebServerFactoryCustomizer
- ErrorMvcAutoConfiguration : [[2.Ref(데이터 및 정보 저장)/Spring/Exception/BasicErrorController|BasicErrorController]] 사용할 때 자동으로 페이지 등록
## 에러 처리 방법
- [[2.Ref(데이터 및 정보 저장)/Spring/Exception/BasicErrorController|BasicErrorController]] 
- [[2.Ref(데이터 및 정보 저장)/Spring/Exception/HandlerExceptionResolver|HandlerExceptionResolver]]
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ExceptionHandler|@ExceptionHandler]] 
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ResponseStatus|@ResponseStatus]]
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ControllerAdvice|@ControllerAdvice]] 
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RestControllerAdvice|@RestControllerAdvice]] 

### 단순한 Exception 처리 방법
특정 HTTP STATUS 일 경우 반환되는 페이지 또는 상태 처리
특정 Exception 일 경우 반환되는 페이지 또는 상태 처리

| 페이지 등록 방법                 | 에러 처리 방법                                                                           | 설명                                                                                                                                                                                                       |
| ------------------------- | ---------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| web.xml                   | 동일                                                                                 | Spring MVC 시절 쓰던 방법<br>장점 : 한 눈에 무슨 에러때 사용할지 설정 가능<br>단점 : 디테일한 설정 불가능(Exception이면 특정 Exception 종속이거나 상태 코드에 종속적)<br>갑자기 설정파일로 수정해야하기 때문에 연속성이 떨어짐                                                       |
| WebServerCustomizer       | 동일                                                                                 | web.xml 방식과 동일하지만 java로 설정 할 수 있다는 차이점                                                                                                                                                                   |
| ErrorMvcAutoConfiguration | [[2.Ref(데이터 및 정보 저장)/Spring/Exception/BasicErrorController\|BasicErrorController]] | 기본 기능인 [[2.Ref(데이터 및 정보 저장)/Spring/Exception/BasicErrorController\|BasicErrorController]] 사용할 경우 `server.error.path` 이용해서 경로 설정 가능<br>페이지 등록일 경우 단순하게 등록만 해놓으면 사용 가능<br>디테일한 설정 불가능(특정 컨트롤러의 특정 에러 처리 등) |

### 복잡한 Exception 처리 방법
HTTP STATUS or Exception or Controller 조건에 따라 다르게 처리할 수 있는 방법
[[2.Ref(데이터 및 정보 저장)/Spring/Exception/HandlerExceptionResolver|HandlerExceptionResolver]] 를 어떻게하면 좀 더 편하고 의미적이게 사용할 수 있을지에 대한 방법

- [[2.Ref(데이터 및 정보 저장)/Spring/Exception/HandlerExceptionResolver|HandlerExceptionResolver]]
	복잡한 상황까지 처리 가능
	단점 : 페이지 처리는 상관 없지만 API 처리일 경우 원초적인 방법으로 처리
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ExceptionHandler|@ExceptionHandler]]
	[[2.Ref(데이터 및 정보 저장)/Spring/Exception/HandlerExceptionResolver#`ExceptionHandlerExceptionResolver`|ExceptionHandlerExceptionResolver]] 통해서 처리
	특정 컨트롤러 안에서만 등록 가능 ([[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ControllerAdvice|@ControllerAdvice]] 또는 [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RestControllerAdvice|@RestControllerAdvice]] 사용할 경우 그룹형식으로 처리 가능)
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ResponseStatus|@ResponseStatus]]
	[[2.Ref(데이터 및 정보 저장)/Spring/Exception/HandlerExceptionResolver#`ResponseStatusExceptionResolver`|ResponseStatusExceptionResolver]] 통해 처리
	단순한 HTTP 상태 전달 기능
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ControllerAdvice|@ControllerAdvice]] 
- [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RestControllerAdvice|@RestControllerAdvice]]
	[[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ExceptionHandler|@ExceptionHandler]]과 [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@InitBinder|@InitBinder]] 모듬집으로 사용 가능
	특정 어노테이션, 패키지, 컨트롤러를 대상으로 설정 가능

## `web.xml` 방법
예전 Spring MVC를 사용할때 시절 쓰던 방법
```xml title:"Spring MVC 시절 error 처리 xml 작성 방법"
<web-app>
	<error-page>
	
	<error-code>404</error-code>
	<location>/error-page/404.html</location>
	</error-page>
	<error-page>
	
	<error-code>500</error-code>
	<location>/error-page/500.html</location>
	</error-page>
	<error-page>
	<exception-type>java.lang.RuntimeException</exception-type>
	<location>/error-page/500.html</location>
	
	</error-page>
</web-app>
```

## spring boot의 직접 등록 방법
```java
@Component  
public class WebServerCustomizer implements WebServerFactoryCustomizer<ConfigurableWebServerFactory> {  
  @Override  
  public void customize(ConfigurableWebServerFactory factory) {  
    ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, "/error-page/404");  
    ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, "/error-page/500");  
    ErrorPage errorPageEx = new ErrorPage(RuntimeException.class, "/error-page/500");  
  
    factory.addErrorPages(errorPage404, errorPage500, errorPageEx);  
  }  
}
```

[[2.Ref(데이터 및 정보 저장)/Spring/Exception/BasicErrorController|BasicErrorController]] 기본적으로 설정된 방법

[[2.Ref(데이터 및 정보 저장)/Spring/Exception/HandlerExceptionResolver|HandlerExceptionResolver]] 직접 설정은 모두 ExceptionResolver를 통해서 만들어짐
[[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ExceptionHandler|@ExceptionHandler]], [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ResponseStatus|@ResponseStatus]] 둘 다 ExceptionResolver를 이용해 만들어짐


[[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ControllerAdvice|@ControllerAdvice]] 또는 [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RestControllerAdvice|@RestControllerAdvice]] 둘 다 동일한 기능이며 각종 [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ExceptionHandler|@ExceptionHandler]] 와 [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@InitBinder|@InitBinder]] 묶음 집합을 적용시키는 방법이라고 생각하는 것이 편리






> [!danger] 이거 다시 좀 구조를 생각할 필요가 있겠는데
> 어떻게 써야할지 좀 햇갈려


