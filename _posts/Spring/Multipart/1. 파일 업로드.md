---
aliases:
  - 1. 파일 업로드
tags:
  - Spring
  - index
특징: 
---
# Multipart 설정
```properties
# 파일 하나의 최대 사이즈, 기본 1MB
spring.servlet.multipart.max-file-size=1MB
# 멀티파트 요청 하나에 여러 파일을 업로드 할 수 있는데, 그 전체 합 기본 10MB
spring.servlet.multipart.max-request-size=10MB
# multipart 기능을 끄고 켤지 선택 (default:true)
spring.servlet.multipart.enabled=true
```

# 폼 전송하는 방식
- `application/x-www-form-urlencoded`
- `multipart/form-data`

## `application/x-www-form-urlencoded`
폼으로 파일 첨부가 아닌 단순 데이터 전달의 모습
```html
<form action="/save" method="post">
	<input type="text" name="username"/>
	<input type="text" name="age"/>
</form>
```
> 해당 폼의 형태를 데이터로 전송하게 되면 아래 모습으로 전달
```http
POST /save HTTP/1.1
Host: localhost:8080
Content-Type:application/x-www-form-urlencoded

username=kim&age=20
```

## `multipart/form-data`
파일 전송을 위한 form 사용
```html
<form action="/save" method="post" enctype="multipart/form-data">
	<input type="text" name="username"/>
	<input type="text" name="age"/>
	<input type="file" name="file1"/>
	<button type="submit">전송</button>
</form>
```
> 해당 폼의 형태를 데이터로 전송하게 되면 아래 모습으로 전달
```http
POST /save HTTP/1.1
Host: localhost:8080
Content-Type: multipart/form-data; boundary=-----XXX
-----XXX
Content-Disposition:form-data;name="username"

kim
-----XXX
Content-Disposition:form-data;name="age"

20
-----XXX
Content-Disposition:form-data;name="file1";filename="intro.png"
Content-Type:image/png

109238a9o0p3eqwokjasd09ou3oirjwoe9u34ouief...
-----XXX--
```
> 맨 끝에는 -- 두개를 붙여서 마지막인것을 알림

### 처리 방법
서블릿에 의한 처리 방법으로는 [[2.Ref(데이터 및 정보 저장)/Spring/Multipart/Part|Part]]를 이용한 방법이 있으며 몇가지 단점이 있기 때문에 Spring 에서는 [[2.Ref(데이터 및 정보 저장)/Spring/Multipart/MultipartFile|MultipartFile]] 를 제공


### `MultipartHttpServletRequest`
`spring.servlet.multipart.enabled=true` 일 경우 `MultipartResolver` 실행
`MultipartResolver`는 멀티파트 요청인 경우 서블릿 컨테이너가 전달하는 `HttpServletRequest`가 아닌 `MultipartHttpServletRequest`로 변환하여 반환
보통 `MultipartFile`을 사용하는 것이 `MultipartHttpServletRequest`를 사용하는 것보다 편의성이 높기 때문에 따로 특별히 사용하지 않음
해당 인터페이스의 구현체는 `StandardMultipartHttpServletRequest`이 있음



### 혹시나 전체 메시지를 보고 싶다면
```http
POST /servlet/v1/upload HTTP/1.1
Host: localhost:8080
Connection: keep-alive
Content-Length: 300
Cache-Control: max-age=0
sec-ch-ua: "Not A(Brand";v="99", "Google Chrome";v="121", "Chromium";v="121"
sec-ch-ua-mobile: ?0
sec-ch-ua-platform: "macOS"
Upgrade-Insecure-Requests: 1
Origin: http://localhost:8080
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryjB3BUHmwUYmhhk6R
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: http://localhost:8080/servlet/v1/upload
Accept-Encoding: gzip, deflate, br
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
Cookie: JSESSIONID=8BFC73DC7BCB55B7AFF1559F734A293E

------WebKitFormBoundaryjB3BUHmwUYmhhk6R
Content-Disposition: form-data; name="itemName"

sanwa
------WebKitFormBoundaryjB3BUHmwUYmhhk6R
Content-Disposition: form-data; name="file"; filename="test.txt"
Content-Type: text/plain

Hello I'm dongmin

------WebKitFormBoundaryjB3BUHmwUYmhhk6R--
```


# 업로드
```html
<form th:action method="post" enctype="multipart/form-data">  
    <ul>  
        <li>상품명 <input type="text" name="itemName"></li>  
        <li>첨부파일<input type="file" name="attachFile" ></li>  
        <li>이미지들<input type="file" multiple="multiple" name="imageFiles" ></li>  
    </ul>  
    <input type="submit"/>
</form>
```
> 해당 Form 으로 전달할 때
```java title:""
@PostMapping("/upload")  
public void upload(@RequestParam String itemName,  
                   @RequestParam List<MultipartFile> imageFiles,  
                   @RequestParam MultipartFile attachFile) throws IOException {  
  log.info("itemName={}", itemName);  
  log.info("imageFiles={}", imageFiles);  
  log.info("attachFile={}", attachFile);  
    attachFile.transferTo(new File(fileStore.getFullPath(attachFile.getOriginalFilename())));  
    imageFiles.forEach(imageFile -> {  
      log.info("imageFile={}", imageFile.getOriginalFilename());  
      try {  
        imageFile.transferTo(new File(fileStore.getFullPath(imageFile.getOriginalFilename())));  
      } catch (IOException e) {  
        throw new RuntimeException(e);  
      }  
    });  
}
```
`transferTo(특정경로|저장할File)`


# 다운로드
클라이언트에서 파일을 다운로드 하는 기능

## `Content-Disposition` 타입
- inline : 기본 값, 내부 또는 웹 페이지로 표시될 수 있음
- attachment : 다운로드 해야함
```java
@GetMapping("/download")  
public ResponseEntity<Resource> downloadAttachement() throws MalformedURLException {  
  String path = "/Users/Documents/TEMP/temp/";  
  String originFileName = "2021-07-25-16-00-00-1.jpg";  
  UrlResource resource = new UrlResource("file:" + path + originFileName);  
  
  String encodedUploadFileName = UriUtils.encode(originFileName, StandardCharsets.UTF_8);  
  String contentDisposition = "attachment; filename=\"" + encodedUploadFileName + "\"";  
  return ResponseEntity.ok()  
          .header(HttpHeaders.CONTENT_DISPOSITION, contentDisposition)
          .body(resource);  
}
```
> `attachment` 는 사용자가 해당 파일을 다운로드해야 함을 나타냄

```java
@ResponseBody  
@GetMapping("/images/{filename}")  
public Resource downloadImage(@PathVariable String filename) throws MalformedURLException {  
  return new UrlResource("file:" + fileStore.getFullPath(filename));  
}
```
> 리소스로 요청하면 그대로 전달하는 방법



