---
aliases: 
tags:
  - Spring
  - index
  - Spring/Converter
특징: 
---
# 변환기
[[2.Ref(데이터 및 정보 저장)/Spring/변환기/Converter|Converter]] [[2.Ref(데이터 및 정보 저장)/Spring/변환기/Formatter|Formatter]] 이 두가지는
[[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RequestParam|@RequestParam]] , [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ModelAttribute|@ModelAttribute]], DB->서버, 서버->DB, 폼 데이터 처리에 사용

[[2.Ref(데이터 및 정보 저장)/Spring/변환기/HttpMessageConverter|HttpMessageConverter]] 이건 [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RequestBody|@RequestBody]] 처리에 사용

추가로 햇갈릴 수 있는 [[2.Ref(데이터 및 정보 저장)/Spring/ArgumentResolver(HandlerMethodArgumentResolver)|ArgumentResolver]]는Request를 통해 들어온 데이터를 처리하는 로직?같은 것이기 때문에 Converter 와 Formatter 를 쓰는 입장이지 같은 급은 아님


# `PropertyEditor`
`Converter` 가 나오기 전에 사용되던 방법으로 동시성 문제가 있어서 타입을 변환할 때 마다 객체를 계속 생성해야하는 단점이 있어서 사장된 방법
```java title:"@ModelAttribute 의 특정 클래스로 감쌓여있을 경우 해당 이름으로 받는게 아닐때는 사용 필요" hl:4
@PostMapping("/api/shows/{showId}/locations")  
public ResponseEntity<CommonResponse> insertShowLocation(  
  @PathVariable Long showId,  
  @ModelAttribute ShowLocationDto showLocationDto,  
  @RequestPart(name="files", required = false) List<MultipartFile> files  
) throws IOException {  
  ShowLocation showLocation = showService.insertShowLocation(showId, showLocationDto, files);  
  return CommonResponse.createResponseEntity(SERVER_STATE_TYPE.CREATED, showLocation);  
}
```
[[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@RequestPart|@RequestPart]] 로 쓰기에는 `ShowLocationDto` 라는 이름으로 묶어서 보내지 않을 경우 자료를 표현하기에  [[2.Ref(데이터 및 정보 저장)/Spring/Annotation/@ModelAttribute|@ModelAttribute]] 를 사용했는데 내부적으로 `List<Long>`형태로 전달이 필요할때 사용할 수 밖에 없음

# [[2.Ref(데이터 및 정보 저장)/Spring/변환기/Converter|Converter]]

# [[2.Ref(데이터 및 정보 저장)/Spring/변환기/Formatter|Formatter]]




```dataview
TABLE
	 file.tags,
	 특징
FROM "/" and #Spring/Converter 
sort 특징 ASC
```