---
aliases:
  - 스프링에서 많이 쓰는 디자인 패턴
tags:
특징:
---


# 템플릿 메서드 패턴
#디자인패턴
![[config/AttachedFile/Pasted image 20240611140214.png|600]]
## 의도
작업에서 알고리즘의 골격을 정의하고 일부 단계를 하위 클래스로 연기
템플릿 메서드를 사용하면 하위 클래스가 알고리즘의 구조를 변경하지 않고도 알고리즘의 특정 단계를 재정의 할 수 있음

## 해설
부모에서 공통적인 것들 다 만들고 자식이 쓸 부분만 `abstract` 로 만들어서 자식 따라서 넣기

## 예제
```java title:"잘 아는 Template"
@Slf4j  
public abstract class AbstractTemplate {  
  public void execute() {  
    long startTime = System.currentTimeMillis();  
  
    call();  
  
    long endTime = System.currentTimeMillis();  
    long resultTime = endTime - startTime;  
    log.info("비즈니스 로직 종료: " + resultTime + "ms");  
  }  
  
  protected abstract void call();  
}
```

```java title:"template inline 형식으로 사용"
 public String order(@RequestParam("itemId") String itemId) {

    AbstractTemplate<String> template = new AbstractTemplate<>(trace) {
      @Override
      protected String call() {
        orderService.orderItem(itemId);
        return "ok";
      }
    };

    return (String) template.execute("OrderController.order()");
}
```

단점 : 부모 클래스에 의존
# 전략 패턴
#디자인패턴 
![[config/AttachedFile/Pasted image 20240611140306.png|600]]
[[#템플릿 콜백 패턴]] 이거랑 다를게 뭔가 똑같은거 같은데
## 의도
알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들기
전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로 알고리즘을 변경 가능 

## 해설
쓰는 곳들은 서로 인터페이스만 공유하여 다른 종속성은 없도록 만듬
Spring 가장 많이 쓰는 방식으로 보임
단점 : 인터페이스 종속성은 남음

## 예제
```java title:"interface"
public interface Strategy {  
  void call();  
}
```

```java title:"직접적으로 사용할 context 부분" hl:3,10
@Slf4j  
public class ContextV2 {  
  public void execute(Strategy strategy) {  
    long startTime = System.currentTimeMillis();  
  
    strategy.call();  
  
    long endTime = System.currentTimeMillis();  
    long resultTime = endTime - startTime;  
    log.info("비즈니스 로직 종료: " + resultTime + "ms");  
  }  
}
```

```java title:"전략 패턴 사용"
@Test  
void strategyV2() {  
  ContextV2 context = new ContextV2();  
  context.execute(() -> log.info("비즈니스 로직1 실행"));  
  context.execute(() -> log.info("비즈니스 로직2 실행"));  
}
```
인터페이스에 의존적인 모습

# 템플릿 콜백 패턴
#디자인패턴 
GOF 디자인패턴으로 있는 패턴은 아니지만 Spring 에서 많이 사용하는 패턴
[[2.Ref(데이터 및 정보 저장)/Spring/Repository/JdbcTemplate|JdbcTemplate]], [[2.Ref(데이터 및 정보 저장)/Spring/Repository/1.Transaction|TransactionTemplate]], [[RedisTemplate]] 처럼 `XXXTemplate` 이 템플릿 콜백 패턴으로 만들어짐

[[#전략 패턴]] 이거랑 다를게 뭔가 똑같은거 같은데
## 의도
콜백(callback) 또는 콜애프터 함수(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말함
콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수 있고 아님 나중에 실행할 수 있음
## 해설
실행할 함수 받아놓고 내가 쓰고 싶을 때 쓰는 패턴
## 예제
```java title:"interface Callback"
public interface TraceCallback<T> {  
  public T call();  
}
```

```java title:"Template"
@Slf4j  
@RequiredArgsConstructor  
public class TraceTemplate {  
  public final LogTrace logTrace;  
  
  public <T> T execute(String classMethodName, TraceCallback<T> callback) {  
    TraceStatus traceStatus = null;  
    try {  
      traceStatus = logTrace.begin(classMethodName);  
  
      T result = callback.call();  
  
      logTrace.end(traceStatus);  
      return result;  
    } catch (Exception e) {  
      logTrace.exception(traceStatus, e);  
      throw e;  
    }  
  }  
}
```
# 프록시 패턴
#디자인패턴 
[[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|Proxy]]사용 
3가지 상황
- 인터페이스와 구현 클래스 존재 - 스프링 빈으로 수동 등록 [[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|Interface Proxy]], [[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|Dynamic Proxy]]  
- 인터페이스가 없고 구현 클래스 존재 - 스프링 빈으로 수동 등록 [[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|Class Proxy]] 
- 컴포넌트 스캔으로 스프링 빈 자동 등록 - [[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|CGLIB]] 
스프링에서는 `ProxyFactory` 라는 것이 [[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|CGLIB]]를 편하게 사용할 수 있게 지원
## 의도
접근 제어를 목적으로 둠
ex) 동작에 오래걸리는 함수의 결과를 미리 캐시 해놓고 값을 반환하는 기능 등
## 해설
# 데코레이터 패턴
#디자인패턴 
[[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/Proxy|Proxy]]사용
## 의도
새로운 기능 추가를 목적으로 둠
## 해설
# ThreadLocal 
Thread 의 경우 pool로 관리되고 있는데 ThreadLocal은 Thread와 연결되어 있어서 이전 Thread 사용자가 남긴 데이터가 그대로 남아 있기 때문에 이후 Tread 사용자는 이전 사용자의 데이터를 사용하게 되어서 문제 발생

[[2.Ref(데이터 및 정보 저장)/Spring/공통관심사/AOP|AOP]] 