---
aliases:
  - 사용자 인증
  - Principal
  - Authentication
  - UsernamePasswordAuthenticationToken
tags:
  - Spring
  - Spring/Security
특징: 사용자 인증 클래스
---
# 사용자 인증
## Principal
![[config/AttachedFile/Pasted image 20240320144848.png|400]]

## Authentication
Java의 기능
`AuthenticationManager.authenticate(Authentication)` 를 통해서 요청이 처리된 후 인증된 주체에 대한 토큰
인증이 완료되면 `SecurityContextHolder`가 관리하는 `SecurityContext`에 저장
```java
  SecurityContext context = SecurityContextHolder.createEmptyContext();
  context.setAuthentication(anAuthentication);
  SecurityContextHolder.setContext(context);
```
> 해당 방법으로 강제로 인증시켜버릴 수 있음



```java
public interface Authentication extends Principal, Serializable {

	/**
	 AuthenticationManager에 의해서 설정됨 (null 불가능)
	 */
	Collection<? extends GrantedAuthority> getAuthorities();

	/**
	 주체의 신원을 증명하는 자격 증명을 반환 (보통은 비밀번호)
	 */
	Object getCredentials();

	/**
	 인증 요청에 대한 추가 세부정보 (IP, 인증서 일련번호 등)
	 사용하지 않을 경우 null
	 */
	Object getDetails();

	/**
	 인증되는 주체의 신원(보통 사용자 이름)
	 */
	Object getPrincipal();

	// 해당 함수에서 true 를 반환할때까지 지속적으로 Provider 들이 인증을 진행
	boolean isAuthenticated();

	/**
	 아마 isAuthenticated() 이거 값인데
	 직접 setAuthenticated 를 사용하게 되면 에러 발생되며 무조건 
	 UsernamePasswordAuthenticationToken result = UsernamePasswordAuthenticationToken.authenticated(principal, 
   authentication.getCredentials(), this.authoritiesMapper.mapAuthorities(user.getAuthorities()));
   형태로 넣어줘야만 가능
	 */
	void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException;

}
```
## UsernamePasswordAuthenticationToken
`Authentication`, `CredentialsContainer` 구현체
`username`과 `password` 를 검증하는 ?    